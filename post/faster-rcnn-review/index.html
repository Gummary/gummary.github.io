<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Faster-RCNN,看这一篇就够了！ - Gum</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="Gum"><meta name=description content="FasterRCNN网络介绍"><meta name=keywords content="Photo,Reading,Java,Distribute System">
<meta name=generator content="Hugo 0.87.0 with theme even">
<link rel=canonical href=http://localhost:1313/post/faster-rcnn-review/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.40f3224b12ad17cb3dd58c8d5dfc3d1d6ad48ed6335de8962e4710a613bf3702.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content="Faster-RCNN,看这一篇就够了！">
<meta property="og:description" content="FasterRCNN网络介绍">
<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:1313/post/faster-rcnn-review/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2019-12-17T11:55:13+00:00">
<meta property="article:modified_time" content="2019-12-17T11:55:13+00:00">
<meta itemprop=name content="Faster-RCNN,看这一篇就够了！">
<meta itemprop=description content="FasterRCNN网络介绍"><meta itemprop=datePublished content="2019-12-17T11:55:13+00:00">
<meta itemprop=dateModified content="2019-12-17T11:55:13+00:00">
<meta itemprop=wordCount content="4402">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Faster-RCNN,看这一篇就够了！">
<meta name=twitter:description content="FasterRCNN网络介绍"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Gum</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a><a href=/categories/>
<li class=mobile-menu-item>Categories</li>
</a><a href=/about/>
<li class=mobile-menu-item>About</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>Gum</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>Categories</a>
</li><li class=menu-item>
<a class=menu-item-link href=/about/>About</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>Faster-RCNN,看这一篇就够了！</h1>
<div class=post-meta>
<span class=post-time> 2019-12-17 </span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>Contents</h2>
<div class="post-toc-content always-active">
<nav id=TableOfContents>
<ul>
<li><a href=#rpn网络>RPN网络</a>
<ul>
<li><a href=#anchor的生成与使用>Anchor的生成与使用</a></li>
<li><a href=#softmax-判定anchor>Softmax 判定anchor</a></li>
<li><a href=#rpn的target生成>RPN的Target生成</a></li>
<li><a href=#bouond-box-regression>Bouond box regression</a></li>
<li><a href=#proposal-layer>Proposal Layer</a></li>
</ul>
</li>
<li><a href=#roi-pooling>RoI Pooling</a>
<ul>
<li><a href=#roi-pooing原理>RoI Pooing原理</a></li>
</ul>
</li>
<li><a href=#classification>Classification</a></li>
<li><a href=#bbox-prediction>BBox Prediction</a></li>
<li><a href=#training>Training</a>
<ul>
<li><a href=#rpnloss>RPNLoss</a></li>
<li><a href=#proposal-net-loss>Proposal Net Loss</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<p>本文将详细介绍著名的目标检测网络FasterRCNN，其网络结构如下图所示：</p>
<p><img alt src=https://i.imgur.com/ZgZvGOb.png></p>
<p>可以看到，FasterRCNN网络由<code>RPN网络</code>及<code>RCNN</code>网络组成，下面分别介绍二者的作用及网络结构。</p>
<h1 id=rpn网络>RPN网络</h1>
<p>RPN网络包括提取特征的骨干网络及进行分类和回归的两个分支。分类分支的作用是预测出可能包含目标的区域而回归分支的作用是回归出包含目标区域的准确坐标。</p>
<p>要预测出目标区域，首先要定义目标区域。在FasterRCNN之前采用的方法有两种：</p>
<ol>
<li>Opencv AdaBoost通过滑动窗口及图像金字塔生成大量区域，然后对这些区域进行分类和回归；</li>
<li>R-CNN使用Selective Search的方法选出目标区域。</li>
</ol>
<p>FasterRCNN则是创造性的提出了Anchor的概念，也即在图像中生成大量的Anchor，然后利用神经网络对Anchor进行分类和回归。</p>
<p><img alt src=https://i.imgur.com/YR2kXUN.jpg></p>
<h2 id=anchor的生成与使用>Anchor的生成与使用</h2>
<p><img alt src=https://i.imgur.com/qeNWvAc.jpg></p>
<p>Faster RCNN在生成的特征图上的每个点都应用9个anchor作为初始的检测框，九个anchor为三种不同比例的检测框，分别为1:1,1:2,2:1。原图800x600，VGG下采样16倍，feature map每个点设置9个Anchor，所以共有</p>
<p>$$
\lceil (800/16) \rceil \times \lceil (600/16) \rceil \times 9 = 50 \times 38 \times 9 = 17100
$$</p>
<p>个检测框。</p>
<h2 id=softmax-判定anchor>Softmax 判定anchor</h2>
<p>利用Backbone提取特征图后，首先利用Conv1x1卷积得到一个$H\times W\times18$的矩阵，表示每个像素点处的9个anchor是正例还是负例。通过Softmax判定是否包含目标，一般认为正例包含目标。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=l>layer {</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;rpn_cls_score&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Convolution&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;rpn/output&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>top</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;rpn_cls_score&#34;</span><span class=w>
</span><span class=w>  </span><span class=l>param { lr_mult: 1.0 }</span><span class=w>
</span><span class=w>  </span><span class=l>param { lr_mult: 2.0 }</span><span class=w>
</span><span class=w>  </span><span class=l>convolution_param {</span><span class=w>
</span><span class=w>    </span><span class=nt>num_output</span><span class=p>:</span><span class=w> </span><span class=m>18</span><span class=w>   </span><span class=c># 2(bg/fg) * 9(anchors)</span><span class=w>
</span><span class=w>    </span><span class=nt>kernel_size: 1 pad: 0 stride</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span><span class=w>    </span><span class=l>weight_filler { type: &#34;gaussian&#34; std: 0.01 }</span><span class=w>
</span><span class=w>    </span><span class=l>bias_filler { type: &#34;constant&#34; value: 0 }</span><span class=w>
</span><span class=w>  </span>}<span class=w>
</span><span class=w></span>}<span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>至于Softmax之前的reshape层是用来将输入$B\times H\times W\times 18$ reshape成$B\times 2\times 9*H\times W$,第二个维度用于存放每个像素处9个anchor的Softmax分类结果，之后的reshape层是用于将其调整回$B\times 18\times H\times W$。</p>
<h2 id=rpn的target生成>RPN的Target生成</h2>
<p>对Anchor进行分类，以下两种情况为正例：</p>
<ol>
<li>遍历Groundtruth，找到IOU最大的Anchor</li>
<li>遍历Anchor找到与Groundtruth的IOU>0.7的值</li>
</ol>
<p>注：一个BBOX可能使多个Anchor为正例</p>
<p>以下两种情况为负例：</p>
<ol>
<li>遍历所有Groundtruth和Anchor，二者之间IOU&lt;0/3的为负例</li>
<li>既不是正例也不是负例的其他Anchor</li>
</ol>
<p>为每个anchor分配类别标签和GroundTruth的坐标过程给你如下：</p>
<ol>
<li>根据Anchor是否超出图像范围剔除无效的Anchor</li>
<li>计算所有有效的Anchor与所有GroundTruth的IOU</li>
<li>为每个GroundTruth找到与之最大IOU的Anchor的位置及IOU大小</li>
<li>为每个Anchor找到与之IOU最大的GroundTruthr的位置及IOU大小</li>
<li>根据4得到的Anchor最大IOU，为大于0.7的Anchor设置为正例，小于0.3的Anchor设置为负例</li>
<li>根据3将具有最大IOU的Anchor设置为正例</li>
</ol>
<p>在训练过程中，为了防止正负例不均衡，通常随机采样256个Anchor，其中正例负例之比为1：1。这里采样的256个Anchor仅用于训练，Proposal的输入是RPN网络的全部输出。</p>
<h2 id=bouond-box-regression>Bouond box regression</h2>
<p>Bounding box回归是为了微调检测框的位置，因为一个Anchor不可能恰好包含一个物体，因此需要对其进行调整。</p>
<p>假设窗口用一个4维向量(x,y,h,w)，分别代表窗口的中心点坐标，高度和宽度。给定anchor $A=(A_x, A_y, A_h, A_w)$和GroundTruth $G=(G_x, G_y, G_h, G_w)$, 则检测框回归的任务是找到一个变换$G' = F(A)$使得$G'\approx G$</p>
<p>这个变换的网络是在RCNN中提出的，变换F包括四个函数$F = {d_x(A), d_y(A),d_h(A),d_w(A)}$,分别用于对中心点做平移变换，对宽和高进行放缩：</p>
<p>$$
\begin{aligned}
G'_x &= A_w d_x(A) + A_x \\\<br>
G'_y &= A_h d_y(A) + A_y \\\<br>
G'_w &= A_w \text{exp}(d_w(A_w)) \\\<br>
G'_h &= A_h \text{exp}(d_h(A_h))
\end{aligned}
$$</p>
<p>这个回归函数的输入是特征图和GroundTruth与anchor的偏移，输出为$d_*(A), *\in{x,y,w,h}$.假设输入的特征图为$\phi(A)$,则：</p>
<p>$$
d_*(A) = W_*^T\phi(A)
$$</p>
<p>则损失函数为：</p>
<p>$$
Loss = \sum_i^N | t_*^i - W_*^T\phi(A) |
$$</p>
<p>其中，$t_*$为GroundTruth与anchor之间的偏移，具体为：</p>
<div>
$$
\begin{aligned}
t_x = \frac{G_x - A_x}{A_w}, \quad t_y = \frac{G_y - A_y}{A_h} \\
t_w = \text{log}(\frac{G_w}{A_w}), \quad t_h = \text{log}(\frac{G_h}{A_h})
\end{aligned}
$$
</div>
<p>最终的优化目标为：</p>
<p>$$
\hat{W}_* = \text{argmin}_{W_*}\sum_i^N | t_*^i - W_*^T\phi(A) | + \lambda |W_*|
$$</p>
<p>在测试时将预测结果变换回检测框时，需要利用上述公式的逆。假设预测出的偏移为$d_*$,预测检测框的位置为$p_*$,$*\in{x,y,w,h}$，则变换函数为：</p>
<div>
$$
\begin{aligned}
&p_x = d_x\times A_w + A_x \\
  &p_y = d_y\times A_y + A_y \\
&p_w = e^{A_w}\times t_w \\
  &p_h = e^{A_h}\times t_h
\end{aligned}
$$
</div>
<p>在实际应用过程中，作者发现当Anchor与GroundTruth距离很远时，这种变换将失去意义，因此对靠近一个GroundTruth的框学习，靠近的定义是Anchor与GroundTruth的IOU大于0.6。</p>
<p>在FasterRCNN中该回归使用一层1x1卷积层实现的,其中每个位置处的输出为36个也即每个anchor都有4个偏移。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=l>layer {</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;rpn_bbox_pred&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Convolution&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;rpn/output&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>top</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;rpn_bbox_pred&#34;</span><span class=w>
</span><span class=w>  </span><span class=l>param { lr_mult: 1.0 }</span><span class=w>
</span><span class=w>  </span><span class=l>param { lr_mult: 2.0 }</span><span class=w>
</span><span class=w>  </span><span class=l>convolution_param {</span><span class=w>
</span><span class=w>    </span><span class=nt>num_output</span><span class=p>:</span><span class=w> </span><span class=m>36</span><span class=w>   </span><span class=c># 4 * 9(anchors)</span><span class=w>
</span><span class=w>    </span><span class=nt>kernel_size: 1 pad: 0 stride</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span><span class=w>    </span><span class=l>weight_filler { type: &#34;gaussian&#34; std: 0.01 }</span><span class=w>
</span><span class=w>    </span><span class=l>bias_filler { type: &#34;constant&#34; value: 0 }</span><span class=w>
</span><span class=w>  </span>}<span class=w>
</span><span class=w></span>}<span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h2 id=proposal-layer>Proposal Layer</h2>
<p>RPN最终的输出为</p>
<ol>
<li>大小为$H\times W\times 2k$的positive/negative softmax分类特征矩阵</li>
<li>大小为$H\times W\times 4k$的bounding box 坐标回归矩阵。</li>
</ol>
<p>Proposal层的作用就是根据2得到更精确的Positive region，送入ROI Pooling Layer中。</p>
<p>该层的定义为</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=l>layer {</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;proposal&#39;</span><span class=w>
</span><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;Python&#39;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;rpn_cls_prob_reshape&#39;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;rpn_bbox_pred&#39;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;im_info&#39;</span><span class=w>
</span><span class=w>  </span><span class=nt>top</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;rpn_rois&#39;</span><span class=w>
</span><span class=w>  </span><span class=l>python_param {</span><span class=w>
</span><span class=w>    </span><span class=nt>module</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;rpn.proposal_layer&#39;</span><span class=w>
</span><span class=w>    </span><span class=nt>layer</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;ProposalLayer&#39;</span><span class=w>
</span><span class=w>    </span><span class=nt>param_str</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;&#39;feat_stride&#39;: 16&#34;</span><span class=w>
</span><span class=w>  </span>}<span class=w>
</span><span class=w></span>}<span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>Proposal层中rpn_cls_prob_reshape为softmax分类特征矩阵， rpn_bbox_pred为bounding box 坐标回归矩阵，im_info为输入图像的大小和缩放信息。这里的缩放信息是指，输入图片后首先将图片缩放到一个固定的尺寸后再输入到网络，这缩放的比例即为im_scales。而param_str中的feat_stride是指特征图经过4次Pooling，共缩放了16倍，用于计算anchor偏移量。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>blobs</span><span class=p>[</span><span class=s1>&#39;im_info&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span>
    <span class=p>[[</span><span class=n>im_blob</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>im_blob</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>3</span><span class=p>],</span> <span class=n>im_scales</span><span class=p>[</span><span class=mi>0</span><span class=p>]]],</span>
    <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float32</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>Proposal层实现的具体步骤为：</p>
<ol>
<li>根据RPN预测的偏移和positive boundingbox生成proposals</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>height</span><span class=p>,</span> <span class=n>width</span> <span class=o>=</span> <span class=n>scores</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=o>-</span><span class=mi>2</span><span class=p>:]</span>

<span class=k>if</span> <span class=n>DEBUG</span><span class=p>:</span>
    <span class=nb>print</span> <span class=s1>&#39;score map size: </span><span class=si>{}</span><span class=s1>&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>scores</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>

<span class=c1># 根据feat_stride和当前特征图的大小计算原图大小</span>
<span class=n>shift_x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>width</span><span class=p>)</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>_feat_stride</span>
<span class=n>shift_y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>height</span><span class=p>)</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>_feat_stride</span>
<span class=n>shift_x</span><span class=p>,</span> <span class=n>shift_y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>meshgrid</span><span class=p>(</span><span class=n>shift_x</span><span class=p>,</span> <span class=n>shift_y</span><span class=p>)</span>
<span class=n>shifts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>((</span><span class=n>shift_x</span><span class=o>.</span><span class=n>ravel</span><span class=p>(),</span> <span class=n>shift_y</span><span class=o>.</span><span class=n>ravel</span><span class=p>(),</span>
                    <span class=n>shift_x</span><span class=o>.</span><span class=n>ravel</span><span class=p>(),</span> <span class=n>shift_y</span><span class=o>.</span><span class=n>ravel</span><span class=p>()))</span><span class=o>.</span><span class=n>transpose</span><span class=p>()</span>

<span class=c1># 生成所有像素点处的anchor</span>
<span class=n>A</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_num_anchors</span>
<span class=n>K</span> <span class=o>=</span> <span class=n>shifts</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=n>anchors</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_anchors</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span> <span class=n>A</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span> <span class=o>+</span> \
          <span class=n>shifts</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span> <span class=n>K</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span><span class=o>.</span><span class=n>transpose</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
<span class=n>anchors</span> <span class=o>=</span> <span class=n>anchors</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=n>K</span> <span class=o>*</span> <span class=n>A</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span>

<span class=c1># 将预测得到的bbox transformation转换为与anchor同样的大小</span>
<span class=c1>#</span>
<span class=c1># bbox deltas will be (1, 4 * A, H, W) format</span>
<span class=c1># transpose to (1, H, W, 4 * A)</span>
<span class=c1># reshape to (1 * H * W * A, 4) where rows are ordered by (h, w, a)</span>
<span class=c1># in slowest to fastest order</span>
<span class=n>bbox_deltas</span> <span class=o>=</span> <span class=n>bbox_deltas</span><span class=o>.</span><span class=n>transpose</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span>

<span class=c1># 对score做同样的操作</span>
<span class=c1>#</span>
<span class=c1># scores are (1, A, H, W) format</span>
<span class=c1># transpose to (1, H, W, A)</span>
<span class=c1># reshape to (1 * H * W * A, 1) where rows are ordered by (h, w, a)</span>
<span class=n>scores</span> <span class=o>=</span> <span class=n>scores</span><span class=o>.</span><span class=n>transpose</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>

<span class=c1># 根据bbox transformation将anchor转换为proposal</span>
<span class=n>proposals</span> <span class=o>=</span> <span class=n>bbox_transform_inv</span><span class=p>(</span><span class=n>anchors</span><span class=p>,</span> <span class=n>bbox_deltas</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><ol start=2>
<li>处理超出图像边界部分的bbox，将图像边界作为超出边界的bbox的边界。</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>clip_boxes</span><span class=p>(</span><span class=n>boxes</span><span class=p>,</span> <span class=n>im_shape</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;
</span><span class=s2>    Clip boxes to image boundaries.
</span><span class=s2>    &#34;&#34;&#34;</span>

    <span class=c1># x1 &gt;= 0</span>
    <span class=n>boxes</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>::</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>maximum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>minimum</span><span class=p>(</span><span class=n>boxes</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>::</span><span class=mi>4</span><span class=p>],</span> <span class=n>im_shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span>
    <span class=c1># y1 &gt;= 0</span>
    <span class=n>boxes</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>::</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>maximum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>minimum</span><span class=p>(</span><span class=n>boxes</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>::</span><span class=mi>4</span><span class=p>],</span> <span class=n>im_shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span>
    <span class=c1># x2 &lt; im_shape[1]</span>
    <span class=n>boxes</span><span class=p>[:,</span> <span class=mi>2</span><span class=p>::</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>maximum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>minimum</span><span class=p>(</span><span class=n>boxes</span><span class=p>[:,</span> <span class=mi>2</span><span class=p>::</span><span class=mi>4</span><span class=p>],</span> <span class=n>im_shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span>
    <span class=c1># y2 &lt; im_shape[0]</span>
    <span class=n>boxes</span><span class=p>[:,</span> <span class=mi>3</span><span class=p>::</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>maximum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>minimum</span><span class=p>(</span><span class=n>boxes</span><span class=p>[:,</span> <span class=mi>3</span><span class=p>::</span><span class=mi>4</span><span class=p>],</span> <span class=n>im_shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>boxes</span>

<span class=n>proposals</span> <span class=o>=</span> <span class=n>clip_boxes</span><span class=p>(</span><span class=n>proposals</span><span class=p>,</span> <span class=n>im_info</span><span class=p>[:</span><span class=mi>2</span><span class=p>])</span>
</code></pre></td></tr></table>
</div>
</div><ol start=3>
<li>去除小于阈值的bbox</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>keep</span> <span class=o>=</span> <span class=n>_filter_boxes</span><span class=p>(</span><span class=n>proposals</span><span class=p>,</span> <span class=n>min_size</span> <span class=o>*</span> <span class=n>im_info</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>
        <span class=n>proposals</span> <span class=o>=</span> <span class=n>proposals</span><span class=p>[</span><span class=n>keep</span><span class=p>,</span> <span class=p>:]</span>
        <span class=n>scores</span> <span class=o>=</span> <span class=n>scores</span><span class=p>[</span><span class=n>keep</span><span class=p>]</span>
</code></pre></td></tr></table>
</div>
</div><ol start=4>
<li>将所有的(proposal, score)对根据score的值进行由高到低排序</li>
<li>取前pre_nms_topN(6000)个值</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>order</span> <span class=o>=</span> <span class=n>scores</span><span class=o>.</span><span class=n>ravel</span><span class=p>()</span><span class=o>.</span><span class=n>argsort</span><span class=p>()[::</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
<span class=k>if</span> <span class=n>pre_nms_topN</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
    <span class=n>order</span> <span class=o>=</span> <span class=n>order</span><span class=p>[:</span><span class=n>pre_nms_topN</span><span class=p>]</span>
<span class=n>proposals</span> <span class=o>=</span> <span class=n>proposals</span><span class=p>[</span><span class=n>order</span><span class=p>,</span> <span class=p>:]</span>
<span class=n>scores</span> <span class=o>=</span> <span class=n>scores</span><span class=p>[</span><span class=n>order</span><span class=p>]</span>
</code></pre></td></tr></table>
</div>
</div><ol start=6>
<li>对剩余positive proposals进行NMS，threshold = 0.7</li>
<li>取NMS后的前post_nms_topN(300)个</li>
<li>返回剩余的proposal</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>keep</span> <span class=o>=</span> <span class=n>nms</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>proposals</span><span class=p>,</span> <span class=n>scores</span><span class=p>)),</span> <span class=n>nms_thresh</span><span class=p>)</span>
<span class=k>if</span> <span class=n>post_nms_topN</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
    <span class=n>keep</span> <span class=o>=</span> <span class=n>keep</span><span class=p>[:</span><span class=n>post_nms_topN</span><span class=p>]</span>
<span class=n>proposals</span> <span class=o>=</span> <span class=n>proposals</span><span class=p>[</span><span class=n>keep</span><span class=p>,</span> <span class=p>:]</span>
<span class=n>scores</span> <span class=o>=</span> <span class=n>scores</span><span class=p>[</span><span class=n>keep</span><span class=p>]</span>
</code></pre></td></tr></table>
</div>
</div><h1 id=roi-pooling>RoI Pooling</h1>
<p>在经过bbox transformation之后，生成的每个bbox都是不同的大小尺寸都不同的，为了保证输入输出尺寸固定且不丢失原始图像的结构和形状，因此采用RoI Pooling的方法。</p>
<h2 id=roi-pooing原理>RoI Pooing原理</h2>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=l>layer {</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;roi_pool_conv5&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;ROIPooling&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;conv5&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;rois&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>top</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;roi_pool_conv5&#34;</span><span class=w>
</span><span class=w>  </span><span class=l>roi_pooling_param {</span><span class=w>
</span><span class=w>    </span><span class=nt>pooled_w</span><span class=p>:</span><span class=w> </span><span class=m>6</span><span class=w>
</span><span class=w>    </span><span class=nt>pooled_h</span><span class=p>:</span><span class=w> </span><span class=m>6</span><span class=w>
</span><span class=w>    </span><span class=nt>spatial_scale</span><span class=p>:</span><span class=w> </span><span class=m>0.0625</span><span class=w> </span><span class=c># 1/16</span><span class=w>
</span><span class=w>  </span>}<span class=w>
</span><span class=w></span>}<span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>RoI Pooling是将每个生成的Proposal都通过pooling的方式变为$\text{pooled}_w\times\text{pooled}_h$的大小，具体步骤为：</p>
<ol>
<li>由于Proposal层输出的Proposal坐标为在原图的左边， 因此首先利用spatial_scale将Proposal变换到特征图上。</li>
<li>将每个特征图上的Proposal划分成$\text{pooled}_w\times\text{pooled}_h$的网格。</li>
<li>对每个网格进行maxpooling</li>
</ol>
<h1 id=classification>Classification</h1>
<p>最后根据RoI Pooling层生成的特征使用全连接层对Proposal进行bounding box regression再次获取更高精度的rect box,使用softmax对proposal进行分类。</p>
<h1 id=bbox-prediction>BBox Prediction</h1>
<p>最终的BoundBox的输出是在每一个PooledFeature上回归得到每一个类别的检测框，对于Pascal VOC数据集，共有21类，因此最终的输出为$4\times 21=84$</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=l>layer {</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;bbox_pred&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;InnerProduct&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>bottom</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;fc7&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>top</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;bbox_pred&#34;</span><span class=w>
</span><span class=w>  </span><span class=l>param {</span><span class=w>
</span><span class=w>    </span><span class=nt>lr_mult</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span><span class=w>  </span>}<span class=w>
</span><span class=w>  </span><span class=l>param {</span><span class=w>
</span><span class=w>    </span><span class=nt>lr_mult</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span><span class=w>  </span>}<span class=w>
</span><span class=w>  </span><span class=l>inner_product_param {</span><span class=w>
</span><span class=w>    </span><span class=nt>num_output</span><span class=p>:</span><span class=w> </span><span class=m>84</span><span class=w>
</span><span class=w>    </span><span class=l>weight_filler {</span><span class=w>
</span><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;gaussian&#34;</span><span class=w>
</span><span class=w>      </span><span class=nt>std</span><span class=p>:</span><span class=w> </span><span class=m>0.001</span><span class=w>
</span><span class=w>    </span>}<span class=w>
</span><span class=w>    </span><span class=l>bias_filler {</span><span class=w>
</span><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;constant&#34;</span><span class=w>
</span><span class=w>      </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=m>0</span><span class=w>
</span><span class=w>    </span>}<span class=w>
</span><span class=w>  </span>}<span class=w>
</span><span class=w></span>}<span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p><strong>class-agnostic与class-specific</strong></p>
<p>前者是指不为每一个类别都预测一个偏移框，仅预测前景和背景，后续通过分类网络得到所有类别的检测结果；后者是指Faster-RCNN采用的方式，为每一个类别都预测一个偏移框。</p>
<h1 id=training>Training</h1>
<p>训练的过程分为4个步骤：</p>
<ol>
<li>根据在imagenet上的pretrain训练RPN网络</li>
<li>利用训练好的RPN得到proposal，训练backbone</li>
<li>利用backbone再次训练RPN</li>
<li>利用再次训练backbone</li>
</ol>
<p>Faster-RCNN的多任务损失函数为：</p>
<p>$$
L({p_i},{t_i}) = \frac{1}{N_{cls}}\sum_iL_{cls}(p_i, p_i^*) + \lambda\frac{1}{N_{reg}}\sum_ip_i^*L_{reg}(t_i, t_i^*)
$$</p>
<p>其中，i为anchor的index，$p_i$为anchor中是否包含物体的概率，$p_i^<em>$为ground truth，当为物体时为1，t_i为预测的bbox的偏移，$t_i^</em>$为正例的ground truth</p>
<h2 id=rpnloss>RPNLoss</h2>
<p>RPNLoss中的输入是有效的Anhcor，所谓有效的Anchor是指在图像内的anchor，里面包含了正例（&lt;=128）负例（>=128）以及不计算Loss的Anchor(label=-1)</p>
<h2 id=proposal-net-loss>Proposal Net Loss</h2>
<p>在训练过程中，Proposal层最终产生2000个Proposal，输入到ProposalTarget中，由该层采样128个Proposal正负例比例为1:3，将这个128个输入到ROIPooling层中得到特征，对然后输入到FC中计算pred_cla和pred_loc，二者均为128个值，然后用预测值与Proposal生成的Target求差计算Loss</p>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>Author</span>
<span class=item-content>Gum</span>
</p>
<p class=copyright-item>
<span class=item-title>LastMod</span>
<span class=item-content>
2019-12-17
</span>
</p>
<p class=copyright-item>
<span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<footer class=post-footer>
<nav class=post-nav>
<a class=prev href=/post/greedy-algorithm/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">贪心算法题汇编</span>
<span class="prev-text nav-mobile">Prev</span>
</a>
</nav>
</footer>
</article>
</div>
<script src=https://utteranc.es/client.js repo=Gummary/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
<noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=mailto:sdythp@gmail.com class="iconfont icon-email" title=email target=_blank></a>
<a href=https://github.com/Gummary/ class="iconfont icon-github" title=github target=_blank></a>
<a href=http://localhost:1313/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=poem>长风破浪会有时，直挂云帆济沧海</div>
<div class=copyright>
<span class=copyright-year>
<span>Gum</span>
&copy;
2017 -
2021</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script>
<script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
</body>
</html>