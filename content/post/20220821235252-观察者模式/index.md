---
title: "设计模式"
slug: desigin-pattern
date: 2022-08-21T23:52:53+08:00
draft: true
---

<!--more-->

# 观察者模式

## 简介

是一种一对多的模式

应用的设计原则：

1. 分离容易变化的和不变的：观察者数量和被观察者状态是变的。
2. 面向接口编程：观察者使用接口注册，被观察者存储接口List
3. 使用组合而不是继承：被观察者包含一些观察者，而不是继承关系

## 缺点

update时可能会出现推送不必要的信息。

解决方案：Subject中定义一些获取信息的接口，由观察者决定获取哪些信息。

但是这种情况不适合多线程。Observer获取信息时，可能Subject的信息已经变化了。

push和pull对比。


# 装饰器模式

装饰器模式主要针对扩展类功能。通常扩展一个类的功能可以使用继承。

使用继承的问题在于，父类的功能不是所有的子类都需要，如果这些功能下沉到子类，则多个子类之间又会有代码的重复。

而如果这些功能发生变化，要么修改父类中的方法。

使用继承来实现类功能的扩展无法满足开闭原则：在**不改变现有代码**的情况下实现**对类功能的扩展**。

使用装饰器模式：

{{< tfigure src="images/20220825132115.png" title="" width="" class="align-center">}}

通过装饰类对原始类进行包装，对原始类的功能进行扩展。

装饰器模式中使用继承来确保装饰后的接口类型不变，而将原始类放到装饰类中，用组合实现对原始类的功能扩展。

在Java的IO工具包中就使用了装饰器模式：

![](images/20220825132539.png)


装饰器模式的缺点：

1. 每个装饰器都是一个类，因此可能会产生很多小的装饰类，不容易理解代码
2. 在客户端需要确切类型的时候不生效
3. 初始化的过程会更加复杂


