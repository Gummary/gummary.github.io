<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Dubbo中的时间轮算法 - Gum</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="Gum"><meta name=description content><meta name=keywords content="Photo,Reading,Java,Distribute System">
<meta name=generator content="Hugo 0.92.1 with theme even">
<link rel=canonical href=http://localhost:1313/post/dubbo3%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.40f3224b12ad17cb3dd58c8d5dfc3d1d6ad48ed6335de8962e4710a613bf3702.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content="Dubbo中的时间轮算法">
<meta property="og:description" content>
<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:1313/post/dubbo3%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-09-13T14:23:35+08:00">
<meta property="article:modified_time" content="2021-09-13T14:23:35+08:00">
<meta itemprop=name content="Dubbo中的时间轮算法">
<meta itemprop=description content><meta itemprop=datePublished content="2021-09-13T14:23:35+08:00">
<meta itemprop=dateModified content="2021-09-13T14:23:35+08:00">
<meta itemprop=wordCount content="3414">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Dubbo中的时间轮算法">
<meta name=twitter:description content><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Gum</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a><a href=/categories/>
<li class=mobile-menu-item>Categories</li>
</a><a href=/about/>
<li class=mobile-menu-item>About</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>Gum</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>Categories</a>
</li><li class=menu-item>
<a class=menu-item-link href=/about/>About</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>Dubbo中的时间轮算法</h1>
<div class=post-meta>
<span class=post-time> 2021-09-13 </span>
<div class=post-category>
<a href=/categories/dubbo/> Dubbo </a>
</div>
<span class=more-meta> 3414 words </span>
<span class=more-meta> 7 mins read </span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>Contents</h2>
<div class="post-toc-content always-active">
<nav id=TableOfContents>
<ul>
<li><a href=#时间轮算法简介>时间轮算法简介</a></li>
<li><a href=#dubbo中的时间轮算法>Dubbo中的时间轮算法</a>
<ul>
<li><a href=#接口介绍>接口介绍</a></li>
<li><a href=#具体实现>具体实现</a></li>
<li><a href=#时间轮算法在dubbo中的应用>时间轮算法在Dubbo中的应用</a></li>
</ul>
</li>
<li><a href=#时间轮算法评价>时间轮算法评价</a></li>
<li><a href=#参考文献>参考文献</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=时间轮算法简介>时间轮算法简介</h1>
<p>时间轮算法是一种非常巧妙、高效的延迟任务调度系统，其算法原理与时钟非常类似。时间轮主要由一个环形队列，一个环形队列指针，多个双向链表组成。</p>
<figure class=align-center>
<img src=https://blog-1302636809.file.myqcloud.com/post/dubbo3%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/images/2021-09-13-16-00-21.png><figcaption>
<h4>时间轮模型</h4></figcaption>
</figure>
<p>环形队列是时间轮的核心结构，队列上的每个节点是一个槽(bucket)，每个槽代表了一个时刻，相邻槽之间的时间间隔(duration)是相等的。在每个槽中都存储一个双向链表的头节点，双向链表中的每个节点代表了需要在该时刻执行的任务。环形队列指针指向的是当前时刻的槽对象。</p>
<p>那么时间轮算法是如何运行的呢。时间轮启动时，从0号槽开始运行，假设时间槽之间的时间间隔为1s，那么每经过1s，队列指针就会向下一个槽移动。然后开始遍历当前槽的任务队列，执行任务队列中的任务。</p>
<p>当有延迟任务要加入到时间轮中时，会首先根据时间间隔计算出应该加入的时间槽中，然后将该任务加入到该时间槽的双向队列中。</p>
<p>如果一个任务需要延迟的时间，超过了一个时间轮所能承载的时间怎么办？比如我们的时间轮现在有12个槽，时间间隔为1s，当前我们在0号槽，那么我们的时间轮最多只能存储未来12秒内的任务，如果我们插入一个需要在13秒执行的任务，那么就会被插入到第1号槽，在下一次调度的时候就会被执行，这就不符合我们的预期了。</p>
<p>解决这个“套圈”问题的方法通常有两个，一个是用多个嵌套的时间轮，内部时间轮的间隔是最小的，而外层的时间轮每个槽的间隔是内层时间轮一圈的时长，类似于我们现实时钟里的时分秒的概念。Kafka中的时间轮算法就采用了这种方式。</p>
<p>还有一种方法是在每个任务中新增一个轮次的字段，表示第几次转到当前槽时执行当前任务。Netty和Dubbo中使用这种方式。下面我们就以Dubbo时间轮的实现为例，看下时间轮算法的具体实现。</p>
<h1 id=dubbo中的时间轮算法>Dubbo中的时间轮算法</h1>
<p>我们先来看一下Dubbo中与时间轮算法相关类的类图：</p>
<figure class=align-center>
<img src=https://blog-1302636809.file.myqcloud.com/post/dubbo3%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/images/2021-09-18-20-56-58.png><figcaption>
<h4>时间轮类图</h4></figcaption>
</figure>
<h2 id=接口介绍>接口介绍</h2>
<p><strong>Timer接口</strong>是Dubbo中的定时器接口，提供了三个方法：</p>
<ul>
<li>newTimeout方法用于向Timer提交一个TimerTask，然后返回一个Timeout句柄，是Timer的核心方法。</li>
<li>stop停止当前定时器，返回所有被取消的TimerTask。</li>
<li>isStop用于判断当前定时器是否停止。</li>
</ul>
<p><strong>Timeout接口</strong>是一个定时任务的句柄，向定时器提交一个定时任务后，会返回该接口的实现类，通过该类提交者可以判断任务的状态：</p>
<ul>
<li>使用isExpired判断一个定时任务是否执行。</li>
<li>使用isCancelled判断一个定时任务是否被取消。</li>
<li>cancel可以取消一个定时任务</li>
</ul>
<p><strong>TimerTask接口</strong>是Dubbo中定时任务的接口，用户定义定时器任务并实现该接口后就可以向Timer提交任务，在设定的时间后就会执行run方法。</p>
<p>Timeout和TimerTask之间的关系其实类似于FutureTask和线程池之间的关系。</p>
<h2 id=具体实现>具体实现</h2>
<p><strong>HashedWheelTimer</strong>（时间轮定时器）在Dubbo中是Timer接口的唯一实现。其核心结构是由HashedWheelBucket数组组成的一个环形列表，HashedWheelBucket中包含一个由HashedWheelTimeout组成的双向链表。其中HashedWheelBucket是时间槽，HashedWheelTimeout是任务句柄。下面我们就看下HashedWheelTimer的具体实现。</p>
<p>在HashedWheelTimer构造函数中，主要初始化时间轮的时间槽，然后使用构造函数中传递的线程工厂创建一个新线程执行Worker的run方法，由于每次初始化一个时间轮时都会创建一个对应的线程，因此只需创建一个全局的时间轮即可。</p>
<p>初始化时间槽时会将时间槽的长度设置为$2^N, N &lt; 30$，目的是根据任务的延迟时间通过位操作快速定位到时间槽。Worker是进行时间槽轮转的“工具人”类，在其run方法中实现了时间轮的推进。</p>
<p>在newTimeout方法中，首先会调用启动函数，如果当前定时器未启动，则启动当前定时器。然后计算出该任务的Deadline，根据Deadline和TimeTask构造出一个HashedWheelTimeout，将HashedWheelTimeout加入到待处理的Timeout队列中。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>Timeout</span> <span class=nf>newTimeout</span><span class=o>(</span><span class=n>TimerTask</span> <span class=n>task</span><span class=o>,</span> <span class=kt>long</span> <span class=n>delay</span><span class=o>,</span> <span class=n>TimeUnit</span> <span class=n>unit</span><span class=o>)</span> <span class=o>{</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=n>start</span><span class=o>();</span>
	<span class=c1>// timeout的deadline是执行时间与时间轮运行时间的差，方便之后计算推进的次数
</span><span class=c1></span>	<span class=kt>long</span> <span class=n>deadline</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>nanoTime</span><span class=o>()</span> <span class=o>+</span> <span class=n>unit</span><span class=o>.</span><span class=na>toNanos</span><span class=o>(</span><span class=n>delay</span><span class=o>)</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=n>HashedWheelTimeout</span> <span class=n>timeout</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashedWheelTimeout</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>task</span><span class=o>,</span> <span class=n>deadline</span><span class=o>);</span>
	<span class=n>timeouts</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>timeout</span><span class=o>);</span>
	<span class=k>return</span> <span class=n>timeout</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面我们来分析下<strong>Worker</strong>类，该类是HashedWheelTimer的内部类。我们直接从该类的run方法看起：</p>
<p>在run中用一个循环不断推进时间轮，在每个循环中按顺序完成以下工作：</p>
<ol>
<li>等待一次推进的时间，也即时间槽之间的间隔时间</li>
<li>通过位运算直接定位到当前的槽函数</li>
<li>处理被取消的任务</li>
<li>将在待处理的任务队列中任务加入到对应的槽函数中</li>
<li>处理当前槽的任务</li>
<li>推进一格时间槽</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
	<span class=c1>// 初始化过程...
</span><span class=c1></span>
	<span class=k>do</span> <span class=o>{</span>
		<span class=kd>final</span> <span class=kt>long</span> <span class=n>deadline</span> <span class=o>=</span> <span class=n>waitForNextTick</span><span class=o>();</span>
		<span class=k>if</span> <span class=o>(</span><span class=n>deadline</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
			<span class=kt>int</span> <span class=n>idx</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=o>(</span><span class=n>tick</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>);</span>
			<span class=n>processCancelledTasks</span><span class=o>();</span>
			<span class=n>HashedWheelBucket</span> <span class=n>bucket</span> <span class=o>=</span> <span class=n>wheel</span><span class=o>[</span><span class=n>idx</span><span class=o>];</span>
			<span class=n>transferTimeoutsToBuckets</span><span class=o>();</span>
			<span class=n>bucket</span><span class=o>.</span><span class=na>expireTimeouts</span><span class=o>(</span><span class=n>deadline</span><span class=o>);</span>
			<span class=n>tick</span><span class=o>++;</span>
		<span class=o>}</span>
	<span class=o>}</span> <span class=k>while</span> <span class=o>(</span><span class=n>WORKER_STATE_UPDATER</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>HashedWheelTimer</span><span class=o>.</span><span class=na>this</span><span class=o>)</span> <span class=o>==</span> <span class=n>WORKER_STATE_STARTED</span><span class=o>);</span>

	<span class=c1>// 将未处理的任务加入到unprocessedTimeouts中...
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>processCancelledTasks中会不断轮询cancelledTimeouts队列，将所有取消的任务都从对应槽的双向链表中移，直至cancelledTimeouts为空。</p>
<p>transferTimeoutsToBuckets方法将待处理的timeout加入到时间槽的双向队列中：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=kt>void</span> <span class=nf>transferTimeoutsToBuckets</span><span class=o>()</span> <span class=o>{</span>
	<span class=c1>// 每次只加100000个任务到时间槽中，防止某个线程不停的向时间轮中提交任务。
</span><span class=c1></span>	<span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>100000</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
		<span class=n>HashedWheelTimeout</span> <span class=n>timeout</span> <span class=o>=</span> <span class=n>timeouts</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
		<span class=k>if</span> <span class=o>(</span><span class=n>timeout</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
			<span class=c1>// 全部处理完成
</span><span class=c1></span>			<span class=k>break</span><span class=o>;</span>
		<span class=o>}</span>
		<span class=k>if</span> <span class=o>(</span><span class=n>timeout</span><span class=o>.</span><span class=na>state</span><span class=o>()</span> <span class=o>==</span> <span class=n>HashedWheelTimeout</span><span class=o>.</span><span class=na>ST_CANCELLED</span><span class=o>)</span> <span class=o>{</span>
			<span class=c1>// 如果timeout被取消了，则直接跳过
</span><span class=c1></span>			<span class=k>continue</span><span class=o>;</span>
		<span class=o>}</span>

		<span class=c1>// 计算出到timeout的deadline之前需要几次推进
</span><span class=c1></span>		<span class=kt>long</span> <span class=n>calculated</span> <span class=o>=</span> <span class=n>timeout</span><span class=o>.</span><span class=na>deadline</span> <span class=o>/</span> <span class=n>tickDuration</span><span class=o>;</span>
		<span class=c1>// 根据推进的次数计算出还需要几轮
</span><span class=c1></span>		<span class=n>timeout</span><span class=o>.</span><span class=na>remainingRounds</span> <span class=o>=</span> <span class=o>(</span><span class=n>calculated</span> <span class=o>-</span> <span class=n>tick</span><span class=o>)</span> <span class=o>/</span> <span class=n>wheel</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>

		<span class=c1>// 确保是未来的任务
</span><span class=c1></span>		<span class=kd>final</span> <span class=kt>long</span> <span class=n>ticks</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>calculated</span><span class=o>,</span> <span class=n>tick</span><span class=o>);</span>
		<span class=c1>// 计算出槽的下标
</span><span class=c1></span>		<span class=kt>int</span> <span class=n>stopIndex</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=o>(</span><span class=n>ticks</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>);</span>
		<span class=c1>// 将timeout加入到对应槽的双向队列中
</span><span class=c1></span>		<span class=n>HashedWheelBucket</span> <span class=n>bucket</span> <span class=o>=</span> <span class=n>wheel</span><span class=o>[</span><span class=n>stopIndex</span><span class=o>];</span>
		<span class=n>bucket</span><span class=o>.</span><span class=na>addTimeout</span><span class=o>(</span><span class=n>timeout</span><span class=o>);</span>
	<span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>得到当前时间槽后，调用时间槽的expireTimeouts方法执行位于该时间槽的方法。</p>
<p>那么我们下面就看一下HashedWheelBucket，时间槽是如何实现的。之前讲过，HashedWheelBucket的数据结构是一个双向链表，所以HashedWheelBucket中定义了很多链表相关的操作，这里不再赘述，我们只看与时间轮算法相关的expireTimeouts方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kt>void</span> <span class=nf>expireTimeouts</span><span class=o>(</span><span class=kt>long</span> <span class=n>deadline</span><span class=o>)</span> <span class=o>{</span>
	<span class=n>HashedWheelTimeout</span> <span class=n>timeout</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
	<span class=c1>// 遍历双向链表
</span><span class=c1></span>	<span class=k>while</span> <span class=o>(</span><span class=n>timeout</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
		<span class=n>HashedWheelTimeout</span> <span class=n>next</span> <span class=o>=</span> <span class=n>timeout</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
		<span class=c1>// 该任务属于当前轮次
</span><span class=c1></span>		<span class=k>if</span> <span class=o>(</span><span class=n>timeout</span><span class=o>.</span><span class=na>remainingRounds</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
			<span class=n>next</span> <span class=o>=</span> <span class=n>remove</span><span class=o>(</span><span class=n>timeout</span><span class=o>);</span>
			<span class=k>if</span> <span class=o>(</span><span class=n>timeout</span><span class=o>.</span><span class=na>deadline</span> <span class=o>&lt;=</span> <span class=n>deadline</span><span class=o>)</span> <span class=o>{</span>
				<span class=n>timeout</span><span class=o>.</span><span class=na>expire</span><span class=o>();</span>
			<span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
				<span class=c1>// The timeout was placed into a wrong slot. This should never happen.
</span><span class=c1></span>				<span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalStateException</span><span class=o>(</span><span class=n>String</span><span class=o>.</span><span class=na>format</span><span class=o>(</span>
						<span class=s>&#34;timeout.deadline (%d) &gt; deadline (%d)&#34;</span><span class=o>,</span> <span class=n>timeout</span><span class=o>.</span><span class=na>deadline</span><span class=o>,</span> <span class=n>deadline</span><span class=o>));</span>
			<span class=o>}</span>
		<span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>timeout</span><span class=o>.</span><span class=na>isCancelled</span><span class=o>())</span> <span class=o>{</span>
			<span class=c1>// 任务已被取消
</span><span class=c1></span>			<span class=n>next</span> <span class=o>=</span> <span class=n>remove</span><span class=o>(</span><span class=n>timeout</span><span class=o>);</span>
		<span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
			<span class=c1>// 任务不属于当前轮次，该任务轮次-1
</span><span class=c1></span>			<span class=n>timeout</span><span class=o>.</span><span class=na>remainingRounds</span><span class=o>--;</span>
		<span class=o>}</span>
		<span class=n>timeout</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
	<span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后我们来看下HashedWheelTimeout类，该类是双向链表中的一个节点，通过该类时间轮的线程执行提交的任务，也通过该类实现对任务的控制。</p>
<p>在expire方法中执行当前timeout背后的方法。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>expire</span><span class=o>()</span> <span class=o>{</span>
	<span class=c1>// 设置任务的执行状态
</span><span class=c1></span>	<span class=k>if</span> <span class=o>(!</span><span class=n>compareAndSetState</span><span class=o>(</span><span class=n>ST_INIT</span><span class=o>,</span> <span class=n>ST_EXPIRED</span><span class=o>))</span> <span class=o>{</span>
		<span class=k>return</span><span class=o>;</span>
	<span class=o>}</span>
	<span class=k>try</span> <span class=o>{</span>
		<span class=c1>// 执行任务
</span><span class=c1></span>		<span class=n>task</span><span class=o>.</span><span class=na>run</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
	<span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Throwable</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
		<span class=k>if</span> <span class=o>(</span><span class=n>logger</span><span class=o>.</span><span class=na>isWarnEnabled</span><span class=o>())</span> <span class=o>{</span>
			<span class=n>logger</span><span class=o>.</span><span class=na>warn</span><span class=o>(</span><span class=s>&#34;An exception was thrown by &#34;</span> <span class=o>+</span> <span class=n>TimerTask</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getSimpleName</span><span class=o>()</span> <span class=o>+</span> <span class=sc>&#39;.&#39;</span><span class=o>,</span> <span class=n>t</span><span class=o>);</span>
		<span class=o>}</span>
	<span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=时间轮算法在dubbo中的应用>时间轮算法在Dubbo中的应用</h2>
<p>时间轮算法在Dubbo中主要有以下几处应用：</p>
<ol>
<li><code>FailbackClusterInvoker</code>中定时重试失败的请求</li>
<li><code>RegistryProtocol</code>中重新发布服务</li>
<li><code>HeaderExchangeClient</code>中实现心跳机制</li>
<li><code>HeaderExchangeServer</code>中用于检测空闲链接</li>
<li><code>DefaultFuture</code>中用于检测调用超超时</li>
</ol>
<h1 id=时间轮算法评价>时间轮算法评价</h1>
<p>从上面的分析可以看出，时间轮算法相对是比较简单的，通过4个类就能实现一个比较高效的任务调度算法。使用双向队列，可以在O(1)复杂度实现调度任务的添加和删除；使用环形链表，线程不必每次都轮询任务队列找到当前时刻需要执行的任务。</p>
<p>但是由于时间轮算法的精度取决于时间间隔的大小，因此无法满足精确调度任务的需求。另外，时间轮任务的执行是在调度线程中完成的，所以如果某个任务包含了阻塞操作，就会影响其他任务的执行。最后，Dubbo中的时间轮算法主要针对一次性的调度任务，如果需要定时重复执行某个任务，就需要在任务执行结束，手动再向时间轮中提交一个任务。</p>
<h1 id=参考文献>参考文献</h1>
<ol>
<li><a href=https://www.cnblogs.com/luozhiyun/p/12075326.html>https://www.cnblogs.com/luozhiyun/p/12075326.html</a></li>
<li><a href=https://segmentfault.com/a/1190000023832602>https://segmentfault.com/a/1190000023832602</a></li>
<li><a href=https://juejin.cn/post/6844904110399946766>https://juejin.cn/post/6844904110399946766</a></li>
<li><a href=https://spongecaptain.cool/post/widget/timingwheel/>https://spongecaptain.cool/post/widget/timingwheel/</a></li>
</ol>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>Author</span>
<span class=item-content>Gum</span>
</p>
<p class=copyright-item>
<span class=item-title>LastMod</span>
<span class=item-content>
2021-09-13
</span>
</p>
<p class=copyright-item>
<span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<footer class=post-footer>
<nav class=post-nav>
<a class=prev href=/post/dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%AD/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Dubbo中的负载均衡策略（中）</span>
<span class="prev-text nav-mobile">Prev</span>
</a>
<a class=next href=/post/dubbo3%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-%E4%B8%8A/>
<span class="next-text nav-default">Dubbo中的负载均衡策略（上）</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i>
</a>
</nav>
</footer>
</article>
</div>
<script src=https://utteranc.es/client.js repo=Gummary/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
<noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=mailto:sdythp@gmail.com class="iconfont icon-email" title=email target=_blank></a>
<a href=https://github.com/Gummary/ class="iconfont icon-github" title=github target=_blank></a>
<a href=http://localhost:1313/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=poem>What I cannot create, I do not understand.</div>
<div class=copyright>
<span class=copyright-year>
<span>Gum</span>
&copy;
2017 -
2022</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script>
<script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
</body>
</html>